\section{Planar Approximation}
It is time to deal with the pole situation. The north and south poles that is, not the lovely people over in Poland. We run into problems because the latitude longitude grid cells become to small 
near the poles. Therefore, the magnitudes no longer fit into one cell and overflow into other cells which makes everything kind of funky. So we need to fix that, and we do that by a planar 
approximation. 

\subsection{The Initial Theory}
As said earlier, the grid cells on the latitude longitude grid get closer together the closer you get to the poles which poses problems. To fix this, we will be using a planar approximation of 
the poles. What this means is that we will map the 3D grid near the poles onto a 2D plane parallel to the poles, as if we put a giant flat plane in the exact center of the poles and draw lines
from the grid directly upwards to the plane. For a visual representation, please consult the stream with timestamp 1:38:25 \cite{polarPlane}, which includes some explanation. In the streamm we
use $r$ to indicate the radius of the planet (which we assume is a sphere), $\theta$ for the longitude and $\lambda$ for the latitude. So we have spherical coordinates, which we need to transform
into $x$ and $y$ coordinates on the plane. We also need the distance between the center point (the point where the plane touches the planet which is the center of the pole) and the projected 
point on the plane from the grid (the location on the plane where a line from the gird upwards to the plane hits it). This distance is denoted by $a$ (Simon chose this one, not me). We then get 
the following equations as shown in \autoref{eq:polar distance}, \autoref{eq:polar x} and \autoref{eq:polar y}. 

\begin{subequations}
    \begin{equation}
        \label{eq:polar distance}
        a = r \cos(\theta)
    \end{equation}
    \begin{equation}
        \label{eq:polar x}
        x = a \sin(\lambda)
    \end{equation}
    \begin{equation}
        \label{eq:polar y}
        y = a \cos(\lambda)
    \end{equation}
\end{subequations}

But what if we know $x$ and $y$ and want to know $\theta$ and $\lambda$? Pythagoras' Theorem then comes into play \cite{pythagoras}. We know that (due to Pythagoras) \autoref{eq:pythagoras} must 
always be true. Then if we substitue $a$ by $\sqrt{x^2 + y^2}$ in \autoref{eq:polar distance} we get \autoref{eq:polar theta1}. Then we transform that equation such that we only have $\theta$ on 
one side and the rest on the other side (since we want to know $\theta$) and we get \autoref{eq:polar theta3}.
\begin{equation}
    \label{eq:pythagoras}
    x^2 + y^2 = a^2
\end{equation}

\begin{subequations}
    \begin{equation}
        \label{eq:polar theta1}
        \sqrt{x^2 + y^2} = r\cos(\theta)
    \end{equation}
    \begin{equation}
        \label{eq:polar theta2}
        \frac{\sqrt{x^2 + y^2}}{r} = \cos(\theta)
    \end{equation}
    \begin{equation}
        \label{eq:polar theta3}
        \arccos(\frac{\sqrt{x^2 + y^2}}{r}) = \theta
    \end{equation}
\end{subequations}

For $\lambda$ we need another trigonometric function which is the tangent ($\tan$). The tangent is defined in \autoref{eq:tan}. If we then take a look at \autoref{eq:polar x} and 
\autoref{eq:polar y}, we see that $\lambda$ is present in both equations. So we need to use both to get $\lambda$ \footnote{Yes you could only use one but since we both know $x$ and $y$ it is a
bit easier to use both than to only use one as you need to know $\theta$ at that point as well which may or may not be the case.}. So let's combine \autoref{eq:polar x} and \autoref{eq:polar y}
in \autoref{eq:polar lambda1}, transform it such that we end up with only $\lambda$ on one side and the rest on the other side and we end up with \autoref{eq:polar lambda3}.

\begin{equation}
    \label{eq:tan}
    \tan(\alpha) = \frac{\sin(\alpha)}{\cos(\alpha)}
\end{equation}

\begin{subequations}
    \begin{equation}
        \label{eq:polar lambda1}
        \frac{x}{y} = \frac{a\sin(\lambda)}{a\cos(\lambda)} = \frac{\sin(\lambda)}{\cos(\lambda)}
    \end{equation}
    \begin{equation}
        \label{eq:polar lambda2}
        \frac{x}{y} = \tan(\lambda)
    \end{equation}
    \begin{equation}
        \label{eq:polar lambda3}
        \lambda = \arctan(\frac{x}{y})
    \end{equation}
\end{subequations}

\subsection{The Grid Code}
To start the planar approximation, we first need to create a grid. Now since the project is made in Python, Simon uses a function to generate a grid from two coordinate vectors (lists with a 
coordinate as elements). Since the documentation is not language specific I instead opt to use words instead of function calls. What that comes down to is use your favourite language and import 
the libraries that do this for you, or start coding your own after finding out how to do that (your mileage may vary). Currently I will not explain how to do this but perhaps in a future update 
I will. Maybe. Anyway, the code for the grid can be found in \autoref{alg:polar grid}. For more explanation about interpolation, please refer to \autoref{sec:interpolation}. Note that the $z$ in 
\autoref{sec:interpolation} refers to $data$, with $x$ and $y$ being $lon$ and $lat$ respectively. The result of the interpolation is a function, and given an $x$ and $y$ coordinate it will give 
back a value. The only thing we still need to do is to convert $x$ and $y$ coordinates into $lat$ and $lon$ coordinates, were we make use of \autoref{eq:polar theta3} 
\footnote{Simon and I disagree whether the arcsin or arccos should be used, however the model is not working as of yet and therefore I opt to leave both in. When everything is working the right 
function will be used. Apologies!} and \autoref{eq:polar lambda3}.

\begin{algorithm}\
    \caption{Generating the grid for polar approximation}
    \label{alg:polar grid}
    $coords_x \leftarrow $ array going from $0$ to $grid\_size$ with steps of $pl_r$ \;
    $coords_u \leftarrow $ array going from $0$ to $grid\_size$ with steps of $pl_r$ \;
    $grid \leftarrow $ turn the coordinate vectors $coords_x$ and $coords_y$ into a grid \;
    $polar\_coords \leftarrow $ empty list (filled in the future with coordinates) \;

    \For{$i \leftarrow 0$ \KwTo $grid.x.length$}{
        \For{$j \leftarrow 0$ \KwTo $grid.x[i].length$}{
            $lat\_point \leftarrow \arcsin(\frac{\sqrt{x^2 + y^2}}{r})$ \;
            $lon\_point \leftarrow \arctan(\frac{grid.x[i, j]}{grid.y[i,j]})$ \;
            $polar\_coords.append(lat\_point, lon\_point)$ \;
        }
    }

    $data \leftarrow 2D$ array filled with 0's, with $nlon$ arrays of size $pl_l$ \;

    \For{$i \leftarrow 0$ \KwTo $pl_l$}{
        $data[i, :] \leftarrow lat[nlat - i]$ \;
    }

    $f \leftarrow$ function resulting from the interpolation of $lon \frac{\pi}{180}$ and $lat \frac{\pi}{180}$ with $data$ as the data points \;
    $index \leftarrow 0$ \;
    \For{$i \leftarrow 0$ \KwTo $grid.x.length$}{
        \For{$j \leftarrow 0$ \KwTo $grid.x[i].length$}{
            $plane[i, j] \leftarrow f(polar\_coords[index][0], polar\_coords[index][1])$ \;
            $index \leftarrow index + 1$ \;
        }
    }
\end{algorithm}